For the position_calculator program, I decided to run through iterations of calculating acceleration, velocity, and then position. I did this because the acceleration relies on one variable (position), while velocity and position each rely on two. My program assumes an initial position on the ground and recalculates all three parameters every .005 seconds, but both initial velocity and the time since launch are user-controlled variables. I did this so that the program is more versatile and useful. 

My program works in steps: at step 0 (n=0), position is 0 and the initial velocity is given by the user. From this information, acceleration can be calculated. The output of the acceleration function is then called 'grav' and is used by the velocity function to calculate a later velocity. That output velocity is stored as 'vel' and is used by the position calculator to produce a new position. Then, the program cycles back and takes a step forward of .005 seconds. Every 200 steps, the program prints the current position; this corresponds to every full second of flight. Also, if the projectile has returned to the ground, the iterative loop is broken and a final position is given. Included in the function is an initial formula to calculate the 'bad position': the height of the projectile if the idealized formula were used. This value is always less than the value calculated later by the program because it assumes constant gravitational acceleration when acceleration actually decreases.

This program is broken into five functions: three equation functions that output the values for acceleration, velocity and position, a function that iterates those three, and a main function that calls the iterative function and presents the results to the user. 