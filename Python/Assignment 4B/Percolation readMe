My main function presents the user with two options: visualize the flow of a fluid through the array or plot a graph of probability of percolation vs. probability of site vacancy. (Executing the first function takes a few seconds; executing the second takes between 20 and 23 minutes). 

For this assignment, I had to design three functions. The first, in the document Percolation.py and called value_assigner, marks sites as blocked, open but unfilled, and filled. It does this by using a recursion process. value_assigner must be given an array full of False values, a randomly-generated array of True and False values, and an array size N. First, it checks a site to see if a site is open (True). If so, it marks in the False array that that site is True. Then, it checks if the site below that is also open. It continues to do this until it is blocked from going down further. Then, it checks left (until blocked from going left) and then right. This is the basic recursion method Professor Cannon recommended in class. I ran into a problem: how do I let the program know where in the array it is and has yet to go? To solve this, I had the program leave a 'breadcrumb trail': every time it goes from one site to another, it marks in a list which way it went. That way, when it can't go left anymore, it traces back to where it first branched in that direction and instead heads right. This way, value_assigner can follow every possible path from top to bottom without traveling down the same path repeatedly and wasting time. 

The second function I designed is also stored in Percolation.py and is called visualize. Visualize asks the user for two inputs, the size of the matrix to visualize and the probability that a given site is vacant. Once given this information, visualize uses the simulator function to generate a random array according to those specifications. It also creates an array of all False values. It then uses the value_assigner function to determine how fluid would percolate through the random array. It then adds the integer forms of the value-assigned array and the False array; this yields a third array, called flow_visual, of 0s, 1s, and 2s, where 0 represents blocked, 1 represents vacant but unfilled, and 2 represents filled. It then plots this array with colored squares.

The third function I designed is also stored in Percolation.py and is called plot. plot generates a graph of the probability of a 20x20 grid percolating as a function of the probability of a site being open. plot divides the possible range for site vacancy probability p (0 to 1) into chunks, with more attention paid to the middle of the range where a steep increase in percolation probability occurs. In total, 100 possible values for p are considered. For each value of p, plot runs 2000 simulations and determines the likelihood that a 20x20 array would percolate. (I ran several tests and determined that 2000 random trials were enough to generate accurate data). It does this by counting the number of times a randomly-generated array percolates and dividing by 2000. Once that value is calculated, it and its corresponding p value are written into arrays; these arrays store the data points for the graph. Once all values for p have been tested and the data point arrays are complete, plot uses pylab to create the graph. 

As a side note, I decided to run a mega version of plot overnight (with 1 million simulations). I included the plot in my submission. It only took 17 hours!