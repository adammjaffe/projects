def boolean_converter(np,N,infile):
    '''This converts a .txt file of 1s and 0s into an array of True and''' \
            '''False values'''
    # Create an 'empty' 1D array of the appropriate size.
    file_array=np.zeros((N,N),bool)
    
    # For each of the remaining rows in the square matrix, read a line and
    # store it as a list temporarily.
    for j in range(1,N+1):
        line=infile.readline()
        line_list=line.split()

        # Convert each item in the line from a 1 or a 0 to a Boolean.
        for k in range(0,len(line_list)):
            if line_list[k]=='0':
                line_list[k]=False
            else:
                line_list[k]=True

            # Write the Boolean value into the correct place in the array.
            file_array[j-1][k]=line_list[k]

    return file_array

def integer_writer(file_array):
    '''This reads an array of Boolean values and writes a .txt file of'''\
            '''1s and 0s.'''
    # Open the write file.
    outfile=open('integers.txt','w')
    
    # Find the size of the array and write that into the outfile.
    N=len(file_array)
    outfile.write(str(N)+'\n')

    for i in range(N):
        # Create a list to temporarily save the integers for the new line.
        temp_list=[]
        for j in range(N):
            # Convert True into 1 and False into 0.
            if file_array[i][j]==True:
                temp_list.append('1')
            else:
                temp_list.append('0')

        # Add a new line marker.
        temp_list.append('\n')

        # Convert the list to a string with proper spacing.
        line=' '.join(temp_list)

        # Write the line to the outfile.
        outfile.write(line)
        
def value_assigner(sites,full,i,j,N):
    '''This takes a simulated square array of length N called sites, an'''\
            '''array full of zeros called full, and the location parameters'''\
            '''i and j and assigns True/False values to locations in full'''\
            '''according to whether or not they can be reached by direct'''\
            '''percolation.'''
    # Create a list to keep track of which direction was traveled to get to
    # a given location.
    directions=['empty']
    
    # Ensure that the location being checked is not blocked and is in the
    # bounds of the array.
    if i<N and j<N and sites[i][j]==True:
        
        # If so,assign the corresponding location in full a True value.
        full[i][j]=True
        
        # Check downwards first: if the location below is in bounds and has a 
        # True value in sites and we haven't checked it yet, proceed.
        if (i<(N-1) and sites[i+1][j]==True and full[i+1][j]==False):
            # Augment the row designation variable.
            i=i+1
            # Add the most recent direction to the list.
            directions.insert(0,'down')
            # Recurse the function.
            value_assigner(sites,full,i,j,N)
            
        # Next, check left.
        if ((j-1)>=0 and sites[i][j-1]==True and full[i][j-1]==False):
            j=j-1
            directions.insert(0,'left')
            value_assigner(sites,full,i,j,N)
            
        # Next, check right.
        if (j<(N-1) and sites[i][j+1]==True and full[i][j+1]==False):
            j=j+1
            directions.insert(0,'right')
            value_assigner(sites,full,i,j,N)

        # If we can't continue down, left, or right, go back the way we came.
        # If we last went down, go up.
        elif (directions[0]=='down' and i>=1 and full[i-1][j]==True):
            # Remove the most recent instruction from the list.
            directions.remove('down')
            # Go backwards.
            i=i-1
            # Recurse the function.
            value_assigner(sites,full,i,j,N)

        # If we last went left, go right.
        elif (directions[0]=='left' and j+1<N and full[i][j+1]==True):
            directions.remove('left')
            j=j+1
            value_assigner(sites,full,i,j,N)

        # If we last went right, go left.
        elif (directions[0]=='right' and j>=1 and full[i][j-1]==True):
            directions.remove('right')
            j=j-1
            value_assigner(sites,full,i,j,N)

    # Return the full array.
    return full

def percolates_or_not(file_array,N):
    '''This takes the array generated by value_assigner and determines if'''\
            '''percolation occurs.'''
    # Create a counting variable for the bottom row of the array.
    counter=0

    # Find the sum of values in the bottom row of the array.
    for i in range(0,N):
        counter=counter+file_array[N-1][i]

    # If the sum of the bottom row is greater than 0, it means at least one
    # column percolates vertically, so the system as a whole does.
    if counter>0:
        return True
    else:
        return False

def simulator(np,N,p):
    '''This generates a 20x20 grid with site vacancy probability p.'''
    import random as r

    # Generate an NxN matrix temporarily full of zeros.
    simulated_array=np.zeros((N,N),bool)

    # Using random.random, fill the sites with 1s or 0s.
    for i in range(0,N):
        for j in range(0,N):
            val=r.random()
            if val<p:
                simulated_array[i][j]=True
            else:
                simulated_array[i][j]=False

    return simulated_array

def visualize(np,mbl,plt):
    # Get values for N and p.
    N=input('How large is the array?')
    p=input('What is the decimal probability that a site is vacant?')

    # Tell the user how to read the plot.
    print 'Blue corresponds to blocked, green to open but unfilled, red to '\
          'open and filled.'

    # Create a completely blocked array called full and a randomized array
    # called sites.
    full=np.zeros((N,N),bool)
    sites=simulator(np,N,p)

    # Assign values to the full array according to whether the locations in
    # the array can or cannot be accessed.
    for k in range(N):
        value_assigner(sites,full,0,k,N)

    # Add the two arrays together when they are in integer form.
    flow_visual=full.astype(int)+sites.astype(int)

    # Convert the array into data for plotting.
    plt.matshow(flow_visual)

    # Show the plot: blue corresponds to blocked, green corresponds to open but
    # empty, red corresponds to open and full.
    plt.show()
    
def plot(np,N,pylab):
    '''This function plots a curve showing the decimal probability that an'''\
            '''NxN array percolates directly as site vacancy probability p'''\
            '''varies from 0 to 1.'''
    # Create an array for p with values focused towards the center of the
    # distribution where curves are expected.
    dist=np.linspace(0,.399,5)
    dist=np.concatenate((dist,np.linspace(.4,.449,10)))
    dist=np.concatenate((dist,np.linspace(.45,.549,20)))
    dist=np.concatenate((dist,np.linspace(.55,.649,40)))
    dist=np.concatenate((dist,np.linspace(.65,.749,20)))
    dist=np.concatenate((dist,np.linspace(.75,1,5)))

    # Create an array to keep track of y values as they are outputted.
    y=np.array([],float)

    # Create a counting variable to keep track of the number of times the
    # randomly-generated grid percolates.
    counter=0

    # Run 1750 simulations for a given value p.
    for i in range(len(dist)):
        p=dist[i]
        for j in range(2500):
            # Create the necessary full array and the simulated array. 
            full=np.zeros((N,N),bool)
            sites=simulator(np,N,p)
            # Assign values for locations: blocked, empty, or filled.
            for k in range(N):
                value_assigner(sites,full,0,k,N)
            file_array=full
            # Determine if the random array percolates.
            yes_or_no=percolates_or_not(file_array,N)
            # Add to the counting variable.
            counter=counter+int(yes_or_no)+.0
        
        # The average value represents the decmial probability that an array of 
        # size N and site vacancy probability p percolates.
        percolation_prob=counter/2500

        # Add the value to the y value array.
        y=np.append(y,percolation_prob)

        # Reset the counting variable.
        counter=0
    
    # Plot y versus p.
    import pylab
    pylab.plot(dist,y)
    pylab.show()
